#/invoice_page.py

from playwright.sync_api import Page
from typing import Optional, List, Dict, Any
from core.logger import Logger
from core.base import BasePage, PatientContext, PatientManager, Patient
import re
from bs4 import BeautifulSoup
from core.base import ClaimItem

class InvoicePage(BasePage):
    def __init__(
        self,
        page: Page,
        logger: Logger,
        context: Optional[PatientContext] = None,
        patient_manager: Optional[PatientManager] = None,
    ):
        super().__init__(page, logger, context)
        self.base_url = "https://revolutionehr.com/static/#/accounting/invoices/dashboard"
        self.patient_manager = patient_manager
    
    def navigate_to_invoices_page(self):
        """Navigate to the invoices dashboard page"""
        
        self.logger.log("Navigating to invoices dashboard...")
        try:
            self.page.goto(self.base_url)
            # Wait for the page to load completely
            self.page.wait_for_selector('[data-test-id="invoiceDashboardReceiveCollectionsPaymentButton"]', timeout=10000)
            self.logger.log("Successfully navigated to invoices dashboard")
        except Exception as e:
            self.logger.log_error(f"Failed to navigate to invoices dashboard: {str(e)}")
            self.take_screenshot("Failed to navigate to invoices dashboard")
            raise

    def set_start_date(self, date_str):
        """Set the start date for invoice search"""
        self.logger.log(f"Setting start date: {date_str}")
        try:
            # Use the stable formcontrolname attribute instead of the dynamic id
            date_input = self.page.locator('[formcontrolname="invoiceDateStart"] input')
            date_input.fill(date_str)
            self.logger.log("Start date set successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to set start date: {str(e)}")
            self.take_screenshot("Failed to set start date")
            raise

    def set_end_date(self, date_str):
        """Set the end date for invoice search"""
        self.logger.log(f"Setting end date: {date_str}")
        try:
            # Use the stable formcontrolname attribute instead of the dynamic id
            date_input = self.page.locator('[formcontrolname="invoiceDateEnd"] input')
            date_input.fill(date_str)
            self.logger.log("End date set successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to set end date: {str(e)}")
            self.take_screenshot("Failed to set end date")
            raise

    def enter_invoice_number(self, number):
        """Enter invoice number for search"""
        self.logger.log(f"Entering invoice number: {number}")
        try:
            # Directly target the input by its form control name.  The dynamic
            # element ids generated by the framework are avoided this way.
            self.page.locator('[formcontrolname="invoiceId"]').fill(number)
            self.logger.log("Invoice number entered successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to enter invoice number: {str(e)}")
            self.take_screenshot("Failed to enter invoice number")
            raise

    def enter_payor_name(self, name):
        """Enter payor name for search"""
        self.logger.log(f"Entering payor name: {name}")
        try:
            # Target the payer name input using its form control name
            self.page.locator('[formcontrolname="payerName"]').fill(name)
            self.logger.log("Payor name entered successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to enter payor name: {str(e)}")
            self.take_screenshot("Failed to enter payor name")
            raise

    def select_location(self, office_location):
        """Select location from dropdown using keyboard simulation.
        
        This method uses a keyboard-based approach to handle complex dropdowns that may not
        respond well to direct element interaction. The approach is particularly useful for:
        - Syncfusion dropdowns
        - Dropdowns with complex JavaScript behavior
        - Dropdowns that require keyboard input for filtering/selection
        
        The sequence:
        1. Click the dropdown icon to focus the input
        2. Type the desired value using keyboard input
        3. Wait briefly for JavaScript to process the input
        4. Press Enter to confirm selection
        5. Tab out to trigger any blur events
        
        If you encounter similar issues with other dropdowns, try this pattern:
        - Use keyboard.type() instead of fill()
        - Add a small wait_for_timeout()
        - Include Enter and Tab for selection and focus management
        """
        self.logger.log(f"Selecting location: {office_location}")
        try:
            # Click the dropdown to focus the input field
            self.page.locator('[formcontrolname="locationId"] .e-input-group-icon').click()
            
            # Type location name
            self.page.keyboard.type(office_location)
            
            # Wait a little for JS to register
            self.page.wait_for_timeout(500)
            
            # Press Enter to "lock in" the selection
            self.page.keyboard.press('Enter')
            
            # Tab to move out of the field
            self.page.keyboard.press('Tab')
            
            self.logger.log("Location selected successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to select location: {str(e)}")
            self.take_screenshot("Failed to select location")
            raise

    def select_payor_type(self, payor_type):
        
        self.logger.log(f"Selecting payor type: {payor_type}")
        try:
            # Click the dropdown to focus the input field
            self.page.locator('[formcontrolname="payerType"] .e-input-group-icon').click()
            
            # Type payor type
            self.page.keyboard.type(payor_type)
            
            # Wait a little for JS to register
            self.page.wait_for_timeout(500)
            
            # Press Enter to "lock in" the selection
            self.page.keyboard.press('Enter')
            
            # Tab to move out of the field
            self.page.keyboard.press('Tab')
            
            self.logger.log("Payor type selected successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to select payor type: {str(e)}")
            self.take_screenshot("Failed to select payor type")
            raise

    def click_search(self):
        """Click the search button"""
        self.logger.log("Clicking search button")
        try:
            self.page.click('[data-test-id="invoiceDashboardSearchButton"]')
            self.logger.log("Search button clicked successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to click search button: {str(e)}")
            self.take_screenshot("Failed to click search button")
            raise

    def get_results_table(self): ## may not be useful anymore. 
        """Get the results table element"""
        self.logger.log("Getting results table")
        try:
            # Get all table rows and filter for those that have text content
            table = self.page.locator('[data-test-id="invoicesTable"] tr').filter(has_text='.')
            self.logger.log("Results table found successfully")
            return table
        except Exception as e:
            self.logger.log_error(f"Failed to get results table: {str(e)}")
            self.take_screenshot("Failed to get results table")
            raise

    def is_loaded(self):
        """Check if the page is loaded"""
        try:
            return self.page.locator('[data-test-id="invoiceDashboardSearchButton"]').is_visible()
        except Exception as e:
            self.logger.log_error(f"Failed to check if page is loaded: {str(e)}")
            return False

    def clear_search_fields(self):
        """Clear all invoice search inputs back to their default state."""
        self.logger.log("Clearing search fields")
        try:
            self.page.locator('[formcontrolname="invoiceDateStart"] input').fill('')
            self.page.locator('[formcontrolname="invoiceDateEnd"] input').fill('')
            self.page.locator('[formcontrolname="invoiceId"]').fill('')
            self.page.locator('[formcontrolname="payerName"]').fill('')
            self.set_approval_status("All")
            self.logger.log("Search fields cleared")
        except Exception as e:
            self.logger.log_error(f"Failed to clear search fields: {str(e)}")
            self.take_screenshot("Failed to clear search fields")
            raise

    def search_invoice(self, invoice_number=None, start_date=None, end_date=None,
                        payor=None, location=None, payor_type=None,
                        age_range=None, approval_status=None):
        """Perform a complete invoice search with optional parameters."""
        self.logger.log("Starting invoice search")
        try:
            # Always reset fields first to avoid stale filters
            self.clear_search_fields()

            if start_date:
                self.set_start_date(start_date)
            if end_date:
                self.set_end_date(end_date)
            if invoice_number:
                self.enter_invoice_number(invoice_number)
            if payor:
                self.enter_payor_name(payor)
            if location:
                self.select_location(location)
            if payor_type:
                self.select_payor_type(payor_type)
            if age_range:
                self.select_invoice_age(age_range)
            if approval_status:
                self.set_approval_status(approval_status)

            self.click_search()
            self.logger.log("Invoice search completed successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to complete invoice search: {str(e)}")
            self.take_screenshot("Failed to complete invoice search")
            raise

    def select_invoice_age(self, age_range):
        self.logger.log(f"Selecting invoice age range: {age_range}")
        try:
            # Click the dropdown to focus the input field
            self.page.locator('[formcontrolname="invoiceAge"] .e-input-group-icon').click()
            
            # Type age range
            self.page.keyboard.type(age_range)
            
            # Wait a little for JS to register
            self.page.wait_for_timeout(500)
            
            # Press Enter to "lock in" the selection
            self.page.keyboard.press('Enter')
            
            # Tab to move out of the field
            self.page.keyboard.press('Tab')
            
            self.logger.log("Invoice age range selected successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to select invoice age range: {str(e)}")
            self.take_screenshot("Failed to select invoice age range")
            raise

    def set_approval_status(self, status):
        """Set approval status where status can be:
        "All" - clicks authorized-0
        "Authorized" - clicks authorized-1
        "Pending" - clicks authorized-2
        """
        status_map = {
            "All": "authorized-0",
            "Authorized": "authorized-1",
            "Pending": "authorized-2"
        }
        
        if status not in status_map:
            raise ValueError(f"Invalid status. Must be one of: {', '.join(status_map.keys())}")
            
        self.logger.log(f"Setting approval status: {status}")
        try:
            # Click the appropriate button based on status
            self.page.locator(f'[data-test-id="{status_map[status]}"]').click()
            self.logger.log("Approval status selected successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to select approval status: {str(e)}")
            self.take_screenshot("Failed to select approval status")
            raise

    def click_invoice_details_tab(self):
        """Click the Invoice Details tab"""
        self.page.locator('[data-test-id="invoiceDetailsDetailTab"]').click()
        
    def click_additional_claim_info_tab(self):
        """Click the Additional Claim Info tab"""
        self.page.locator('[data-test-id="invoiceDetailsAdditionalClaimInfoTab"]').click()
        
    def click_claim_history_tab(self):
        """Click the Claim History tab"""
        self.page.locator('[data-test-id="invoiceDetailsClaimHistoryTab"]').click()
        
    def click_payment_history_tab(self):
        """Click the Payment History tab"""
        self.page.locator('[data-test-id="invoiceDetailsPaymentHistoryTab"]').click()
        
    def click_statement_history_tab(self):
        """Click the Statement History tab"""
        self.page.locator('[data-test-id="invoiceDetailsStatementHistoryTab"]').click()
        
    def click_docs_and_images_tab(self):
        """Click the Docs and Images tab"""
        self.page.locator('[data-test-id="invoiceDetailsDocsAndImagesTab"]').click()
        
    def click_notes_tab(self):
        """Click the Notes tab"""
        self.page.locator('[data-test-id="invoiceDetailsNotesTab"]').click()

    def click_pending_authorization(self):
        """Click the Pending authorization button"""
        self.page.locator('[data-test-id="false"]').click()
        
    def click_authorized(self):
        """Click the Authorized button"""
        self.page.locator('[data-test-id="true"]').click()

    def add_note(self, note_text):
        """Add a note to the current invoice.
        
        Args:
            note_text (str): The text of the note to add
        """
        print(f"Adding note: {note_text}")
        try:
            # Fill in the note text
            self.page.get_by_role('textbox', name='textbox').fill(note_text)
            
            # Click the save button
            self.page.locator('[data-test-id="saveAddEditNoteButton"]').click()
            
            print("Note saved successfully")
        except Exception as e:
            self.logger.log_error(f"Failed to add note: {str(e)}")
            self.take_screenshot("Failed to add note")
            raise

    def process_patient_name(self, row):
        """Callback function to handle patient name in a row.
        Opens the patient details in a new tab, prints the name, and closes the tab.
        """
        print("Processing patient name")
        try:
            # Get the patient name cell using the specific col-id
            patient_cell = row.locator('[col-id="patientName"]')
            patient_name = patient_cell.inner_text()
            
            # Get the invoice ID
            invoice_id = row.locator('[col-id="id"]').inner_text()
            print(f"Processing patient: {patient_name} (Invoice: {invoice_id})")
            
            # Click to open new tab
            patient_cell.click()
            
            # Wait for new tab to be ready
            self.page.wait_for_selector('[data-test-id="invoiceDetailsDetailTab"]', timeout=10000)
            
            # Click through all tabs in sequence
            print("Clicking through all tabs...")
            self.click_invoice_details_tab()
            self.click_additional_claim_info_tab()
            self.click_claim_history_tab()
            self.click_payment_history_tab()
            self.click_statement_history_tab()
            self.click_docs_and_images_tab()
            self.click_notes_tab()
            
            # Add a note with the patient name and invoice ID
            note_text = f"Processed by automation - Patient: {patient_name}, Invoice: {invoice_id}"
            self.add_note(note_text)
            
            # Click authorization status buttons
            print("Clicking authorization status buttons...")
            self.click_pending_authorization()
            self.click_authorized()
            
            print(f"Completed processing tabs for: {patient_name}")
            
            # Close the tab by finding the specific tab with this invoice ID
            self.page.get_by_role('tab', name=f"#{invoice_id}").get_by_title('Close').click()
            
            # Wait for main page to be ready
            self.page.wait_for_selector('.ag-center-cols-container')
            
        except Exception as e:
            self.logger.log_error(f"Failed to process patient name: {str(e)}")
            self.take_screenshot("Failed to process patient name")
            raise

    def process_table_rows(self, action_callback=None):
        """Process all rows in the table across all pages.
        
        Args:
            action_callback: Function to execute on each row. If None, uses process_patient_name
        """
        try:
            page_num = 1
            while True:  # Loop until no more pages
                print(f"Processing page {page_num}")
                
                # Wait for AG Grid to be loaded
                self.page.wait_for_selector('.ag-center-cols-container', timeout=10000)
                
                # Get current page rows using AG Grid selector
                rows = self.page.locator('.ag-center-cols-container .ag-row').all()
                print(f"Found {len(rows)} rows on page {page_num}")
                
                if len(rows) == 0:
                    print("No rows found on page - waiting for content...")
                    self.page.wait_for_timeout(2000)  # Give it a moment to load
                    rows = self.page.locator('.ag-center-cols-container .ag-row').all()
                    print(f"After wait: Found {len(rows)} rows on page {page_num}")
                    
                    if len(rows) == 0:
                        print("Still no rows found - table may be empty or loading")
                        break
                
                # Process each row
                for i in range(len(rows)):
                    # Re-fetch the row to avoid stale elements
                    row = self.page.locator('.ag-center-cols-container .ag-row').nth(i)
                    
                    # Use the provided callback if available, otherwise use default process_patient_name
                    if action_callback:
                        action_callback(row)
                    else:
                        self.process_patient_name(row)
                
                # Check for next page button with timeout
                try:
                    next_button = self.page.get_by_role('navigation').get_by_title('Go to next page', exact=True)
                    
                    # Wait for button to be visible with timeout
                    if not next_button.is_visible(timeout=5000):
                        print("Next button not visible - reached last page")
                        break
                        
                    # Check if button is disabled
                    button_class = next_button.get_attribute('class', timeout=5000)
                    if 'e-disable' in button_class:
                        print("Next button is disabled - reached last page")
                        break
                        
                    print("Clicking next page button")
                    next_button.click()
                    
                    # Wait for table to reload
                    self.page.wait_for_selector('.ag-center-cols-container', timeout=10000)
                    page_num += 1
                    
                except Exception as e:
                    print(f"Error checking next page button: {str(e)}")
                    print("Assuming we've reached the last page")
                    break
                
        except Exception as e:
            self.logger.log_error(f"Failed to process table rows: {str(e)}")
            self.take_screenshot("Failed to process table rows")
            raise

    def dummy_claim_review(self, row):
        """Dummy function to demonstrate callback functionality.
        Opens invoice, goes to notes tab, and adds a timestamped review note.
        
        Args:
            row: The row element to process
        """
        print("Starting dummy claim review")
        try:
            # Get the invoice ID before clicking
            invoice_id = row.locator('[col-id="id"]').inner_text()
            print(f"Processing invoice: {invoice_id}")
            
            # Click to open new tab
            row.locator('[col-id="patientName"]').click()
            
            # Wait for new tab to be ready
            self.page.wait_for_selector('[data-test-id="invoiceDetailsDetailTab"]', timeout=10000)
            
            # Go directly to notes tab
            self.click_notes_tab()
            
            # Click the Add Note button to open the textbox
            self.page.locator('[data-test-id="notesAddButton"]').click()
            
            # Add timestamped note
            note_text = "reviewed claim"
            self.page.get_by_role('textbox', name='textbox').fill(note_text)
            self.page.locator('[data-test-id="saveAddEditNoteButton"]').click()
            
            print("Note added successfully")
            
            # Close the tab
            self.page.get_by_role('tab', name=f"#{invoice_id}").get_by_title('Close').click()
            
            # Wait for main table to be ready
            self.page.wait_for_selector('.ag-center-cols-container')
            
            print(f"Completed processing invoice: {invoice_id}")
            
        except Exception as e:
            self.logger.log_error(f"Failed to process dummy claim review: {str(e)}")
            self.take_screenshot("Failed to process dummy claim review")
            raise

    def check_for_document(self):
        """Check if any documents exist in the Documents and Images tab.
        
        Returns:
            bool: True if the document count badge exists (indicating documents are present)
        """
        try:
            # Wait for the documents tab to be present
            self.page.wait_for_selector('[data-test-id="invoiceDetailsDocsAndImagesTab"]', timeout=10000)
            
            # Look for the badge that shows document count
            count_badge = self.page.locator('[data-test-id="invoiceDetailsDocsAndImagesTab"] .badge.margin-left-xs')
            
            # Check if the badge exists
            if count_badge.is_visible(timeout=5000):
                return True
            else:
                return False
            
        except Exception as e:
            self.logger.log_error(f"Failed to check document: {str(e)}")
            self.take_screenshot("Failed to check document")
            return False

    def process_document_check(self, row):
        """Callback function to check for documents and handle workflow.
        If no document exists, it will execute a new function.
        If document exists, it will close and move to next invoice.
        
        Args:
            row: The row element to process
        """
        print("Starting document check workflow")
        try:
            # Get the invoice ID before clicking
            invoice_id = row.locator('[col-id="id"]').inner_text()
            print(f"Processing invoice: {invoice_id}")
            
            # Click to open new tab
            row.locator('[col-id="patientName"]').click()
            
            # Wait for new tab to be ready
            self.page.wait_for_selector('[data-test-id="invoiceDetailsDetailTab"]', timeout=10000)
            
            # Go to Documents and Images tab
            self.click_docs_and_images_tab()
            print('clicked docs and images tab')
            
            # Check for document preview
            exists = self.check_for_document()
            
            if not exists:
                print("No document found - executing additional processing")
                # Here you would call your new function
                # For example:
                # self.process_missing_document(invoice_id)
                # or
                # self.upload_required_document(invoice_id)
                print('no document found, submitting new claim!')
                
                
            else:
                print(f"Document found: {invoice_id} - proceeding to next invoice")
                # Add a note about the found document

            
            # Close the tab
            self.page.get_by_role('tab', name=f"#{invoice_id}").get_by_title('Close').click()
            
            # Wait for main table to be ready
            self.page.wait_for_selector('.ag-center-cols-container')
            
            print(f"Completed processing invoice: {invoice_id}")
            
        except Exception as e:
            self.logger.log_error(f"Failed to process document check: {str(e)}")
            self.take_screenshot("Failed to process document check")
            raise

    def click_patient_name_link(self):
        """Click the patient name link in the invoice header."""
        try:
            self.page.locator('[data-test-id="invoiceHeaderPatientNameLink"]').click()
            self.logger.log("Clicked patient name link successfully")
            # wait for the patient page to load
            self.page.wait_for_selector('[data-test-id="patientHeaderDemographicList"]', timeout=10000)
            self.logger.log("Patient page loaded successfully")
            #wait for a moment to allow a popup to have a chance to appear
            self.page.wait_for_timeout(1000)
            
            #look for popup modal and close it
            try:
                close_button = self.page.locator('[data-test-id="alertHistoryModalCloseButton"]')
                if close_button.is_visible(timeout=3000):  # 3 second timeout
                    close_button.click()
                    self.logger.log("Closed alert history modal after patient selection")
            except Exception as e:
                self.logger.log(f"Alert modal check after patient selection: {str(e)}")
        except Exception as e:
            self.logger.log_error(f"Failed to click patient name link: {str(e)}")
            self.take_screenshot("Failed to click patient name link")
            raise

    def create_patient_from_invoice(
        self,
        default_dob: str = "01/01/1900",
        manager: Optional[PatientManager] = None,
    ) -> Patient:
        """Create a patient object from the invoice header information.
        
        Args:
            default_dob: Default date of birth to use if not found
            manager: PatientManager instance. If not provided, the manager
                attached to this page will be used.
            
        Returns:
            Patient: Newly created patient object
        """
        try:
            # Determine which patient manager to use
            if manager is None:
                manager = getattr(self, "patient_manager", None)
            if manager is None and self.context:
                manager = getattr(self.context, "patient_manager", None)
            if manager is None:
                raise ValueError(
                    "No PatientManager provided and none available on InvoicePage"
                )
            
            # Get patient name from header
            name_element = self.page.locator('[data-test-id="invoiceDetailsPatientName"]')
            if not name_element.is_visible():
                raise Exception("Patient name element not found")
                
            full_name = name_element.text_content().strip()
            if not full_name:
                raise Exception("Patient name is empty")
                
            # Split name into first and last
            name_parts = full_name.split()
            if len(name_parts) < 2:
                raise Exception(f"Invalid patient name format: {full_name}")
                
            first_name = name_parts[0]
            last_name = name_parts[-1]
            
            # Create new patient
            patient = manager.create_patient(
                first_name=first_name,
                last_name=last_name,
                dob=default_dob
            )
            
            self.logger.log(f"Created patient: {first_name} {last_name}")
            return patient
            
        except Exception as e:
            self.logger.log_error(f"Failed to create patient from invoice: {str(e)}")
            self.take_screenshot("Failed to create patient from invoice")
            raise

    def click_invoice_tab(self, invoice_id):
        """Click the invoice tab for a specific invoice ID.
        
        Args:
            invoice_id (str): The invoice ID to identify the correct tab
        """
        try:
            self.page.get_by_role('tab', name=f"#{invoice_id}").click()
            self.logger.log(f"Clicked invoice tab for invoice: {invoice_id}")
        except Exception as e:
            self.logger.log_error(f"Failed to click invoice tab: {str(e)}")
            self.take_screenshot("Failed to click invoice tab")
            raise

    def scrape_invoice_details(self, patient, default_diagnosis='H52.223'):
        """Scrape invoice details from the current invoice page.
        
        Args:
            patient: Patient object to store the scraped data
            default_diagnosis: Default diagnosis code to use if none found (defaults to 'H52.223')
        """
        try:
            # Get the page content and parse with BeautifulSoup
            html_content = self.page.content()
            soup = BeautifulSoup(html_content, 'html.parser')

            # Locate the table
            table = soup.find('div', class_='e-gridcontent').find('table')

            # Initialize a list to store each row's data
            data_rows = []

            # Iterate through the table rows
            for row in table.find_all('tr', class_='e-row'):
                # Extract data from each cell in the row
                cells = row.find_all('td')
                row_data = {
                    'post_date': cells[1].get_text(strip=True),
                    'code': cells[2].get_text(strip=True),
                    'modifiers': cells[3].get_text(strip=True),
                    'diagnoses': cells[4].get_text(strip=True),
                    'description': cells[5].get_text(strip=True),
                    'Qty': cells[6].get_text(strip=True),
                    'Price': cells[10].get_text(strip=True),
                    'copay': cells[11].get_text(strip=True)
                }
                data_rows.append(row_data)

            # Merge duplicate codes
            from decimal import Decimal
            merged_data = {}

            for row in data_rows:
                code = row['code']
                if code in merged_data:
                    # Update existing entry
                    merged_data[code]['Qty'] = str(int(merged_data[code]['Qty']) + int(row['Qty']))
                    merged_data[code]['Price'] = str(Decimal(merged_data[code]['Price'].strip('$')) + Decimal(row['Price'].strip('$')))
                else:
                    # Add new entry
                    merged_data[code] = row
                    merged_data[code]['Price'] = row['Price'].strip('$')

            # Convert to ClaimItem objects and store in patient.claims
            patient.claims = []
            for row in merged_data.values():
                claim_item = ClaimItem(
                    vcode=row['code'],
                    description=row['description'],
                    billed_amount=float(row['Price'].strip('$')),
                    code=row['code'],
                    quantity=int(row['Qty']),
                    modifier=row['modifiers'] if row['modifiers'] else None
                )
                patient.claims.append(claim_item)

            # Store DOS in insurance_data
            if data_rows:
                patient.insurance_data['dos'] = data_rows[0]['post_date']

            # Get doctor name
            doctor_icon = soup.find('i', class_='fa-user-md')
            if doctor_icon:
                doctor_li = doctor_icon.find_parent('li')
                if doctor_li:
                    patient.medical_data['provider'] = doctor_li.get_text(strip=True)

            # Get location
            building_icon = soup.find('i', class_='fa-building')
            if building_icon:
                building_li = building_icon.find_parent('li')
                if building_li:
                    location = building_li.get_text(strip=True)
                    if location == "Borger":
                        patient.demographics['location'] = "Borger"
                    elif location == "Amarillo":
                        patient.demographics['location'] = "Amarillo"
                    else:
                        patient.demographics['location'] = location

            # Handle diagnoses
            if data_rows and data_rows[0]['diagnoses']:
                patient.medical_data['dx'] = data_rows[0]['diagnoses']
            else:
                patient.medical_data['dx'] = default_diagnosis
                # Click diagnosis button and search for H52. pattern
                self.page.locator('[data-test-id="invoiceHeaderDiagnosisButton"]').click()
                
                # Wait for the diagnosis dialog to load
                self.page.wait_for_selector('[data-test-id="selectADiagnosisCancelButton"]', timeout=10000)
                
                # Find diagnosis code
                diagnosis_elements = self.page.locator('[revtooltip]').all()
                for element in diagnosis_elements:
                    text = element.inner_text()
                    if 'H52.' in text:
                        diagnosis_code_pattern = r'H\d{2}\.\d+'
                        match = re.search(diagnosis_code_pattern, text)
                        if match:
                            patient.medical_data['dx'] = match.group(0)
                            break
                
                # Close diagnosis dialog
                self.page.locator('[data-test-id="selectADiagnosisCancelButton"]').click()

            self.logger.log("Successfully scraped invoice details")
            
        except Exception as e:
            self.logger.log_error(f"Failed to scrape invoice details: {str(e)}")
            self.take_screenshot("Failed to scrape invoice details")
            raise

    # ------------------------------------------------------------------
    # Result table utilities
    # ------------------------------------------------------------------

    def _get_rows_on_current_page(self):
        """Return all row locators for the current results page."""
        self.page.wait_for_selector('.ag-center-cols-container', timeout=10000)
        return self.page.locator('.ag-center-cols-container .ag-row')

    def _parse_row_data(self, row) -> Dict[str, Any]:
        """Extract invoice data from a single AG Grid row."""
        try:
            return {
                "approval": row.locator('[col-id="invoice.approval"]').inner_text().strip(),
                "status": row.locator('[col-id="status"]').inner_text().strip(),
                "age": row.locator('[col-id="invoice.invoiceAge"]').inner_text().strip(),
                "invoice_id": row.locator('[col-id="id"]').inner_text().strip(),
                "payer": row.locator('[col-id="invoice.payerName"]').inner_text().strip(),
                "patient_name": row.locator('[col-id="patientName"]').inner_text().strip(),
                "invoice_date": row.locator('[col-id="invoice.invoiceDate"]').inner_text().strip(),
                "service_date": row.locator('[col-id="invoice.serviceDate"]').inner_text().strip(),
                "statement_date": row.locator('[col-id="invoice.statementDate"]').inner_text().strip(),
                "total": row.locator('[col-id="invoice.total"]').inner_text().strip(),
                "balance": row.locator('[col-id="invoice.balance"]').inner_text().strip(),
            }
        except Exception as e:
            self.logger.log_error(f"Failed to parse row data: {str(e)}")
            self.take_screenshot("Failed to parse row data")
            return {}

    def _go_to_next_page(self) -> bool:
        """Click the next page button if available.

        Returns:
            bool: True if navigation occurred, False if already on last page
        """
        try:
            next_button = self.page.get_by_role('navigation').get_by_title('Go to next page', exact=True)
            if not next_button.is_visible(timeout=5000):
                return False
            btn_class = next_button.get_attribute('class')
            if btn_class and 'e-disable' in btn_class:
                return False
            next_button.click()
            self.page.wait_for_selector('.ag-center-cols-container', timeout=10000)
            return True
        except Exception:
            return False

    def scrape_current_page_results(self) -> List[Dict[str, Any]]:
        """Scrape all results from the currently visible table page."""
        rows = self._get_rows_on_current_page()
        results = []
        for i in range(rows.count()):
            row = rows.nth(i)
            data = self._parse_row_data(row)
            if data:
                results.append(data)
        return results

    def scrape_all_search_results(self) -> List[Dict[str, Any]]:
        """Scrape results across all pages of the search table."""
        page_num = 1
        all_results: List[Dict[str, Any]] = []
        while True:
            self.logger.log(f"Scraping results page {page_num}")
            all_results.extend(self.scrape_current_page_results())
            if not self._go_to_next_page():
                break
            page_num += 1
        return all_results

    def open_invoice(
        self,
        invoice_number: Optional[str] = None,
        patient_name: Optional[str] = None,
    ) -> bool:
        """Open an invoice from the results table by invoice number or patient name.

        At least one of ``invoice_number`` or ``patient_name`` must be provided.

        Args:
            invoice_number: The invoice ID to match.
            patient_name: The patient name to match (case-insensitive).

        Returns:
            bool: ``True`` if the invoice was found and opened, ``False`` otherwise.
        """

        if not invoice_number and not patient_name:
            raise ValueError("invoice_number or patient_name must be specified")

        page_num = 1
        while True:
            rows = self._get_rows_on_current_page()
            for i in range(rows.count()):
                row = rows.nth(i)
                match = False

                if invoice_number:
                    inv_id = row.locator('[col-id="id"]').inner_text().strip()
                    if inv_id == str(invoice_number):
                        match = True

                if patient_name and not match:
                    name = row.locator('[col-id="patientName"]').inner_text().strip()
                    if name.lower() == patient_name.lower():
                        match = True

                if match:
                    row.locator('[col-id="id"]').click()
                    # Wait for the invoice details tab to be visible, indicating the invoice is loaded
                    self.page.wait_for_selector('[data-test-id="invoiceDetailsDetailTab"]', timeout=10000)
                    return True

            if not self._go_to_next_page():
                break
            page_num += 1

        return False
                                    
    def close_invoice_tabs(
        self,
        invoice_number: Optional[str] = None,
        close_all: bool = False,
    ) -> int: #WIP DOES NOT WORK
        """Close invoice tabs based on the provided criteria.

        Args:
            invoice_number: Specific invoice number to close. Ignored if
                ``close_all`` is ``True``.
            close_all: If ``True`` close all open invoice tabs.

        Returns:
            int: Number of tabs closed.
        """

        try:
            self.logger.log(
                f"Closing invoice tabs - number={invoice_number}, all={close_all}"
            )

            # Locator matching the <span> element that contains the tab name
            # Example HTML structure:
            # <div class="e-text-wrap">
            #     <div class="e-tab-text">
            #         <span data-test-id="#123.navigationTab">#123</span>
            #     </div>
            #     <span class="e-icons e-close-icon"></span>
            # </div>
            # We grab the <span> with the data-test-id and then locate the
            # sibling close icon from it.
            tab_spans = self.page.locator(
                "[data-test-id^='#'][data-test-id$='.navigationTab']"
            )

            if close_all:
                count = tab_spans.count()
                for i in range(count - 1, -1, -1):
                    span = tab_spans.nth(i)
                    close_icon = span.locator(
                        "xpath=../../span[contains(@class,'e-close-icon')]"
                    )
                    close_icon.click()
                    span.wait_for(state="detached", timeout=5000)
                self.logger.log(f"Closed {count} invoice tab(s)")
                return count

            if invoice_number:
                span = self.page.locator(
                    f"[data-test-id='#{invoice_number}.navigationTab']"
                )
                if span.count() == 0:
                    self.logger.log(f"Invoice tab #{invoice_number} not found")
                    return 0
                close_icon = span.locator(
                    "xpath=../../span[contains(@class,'e-close-icon')]"
                )
                close_icon.click()
                span.wait_for(state="detached", timeout=5000)
                self.logger.log(f"Closed invoice tab #{invoice_number}")
                return 1

            # Default: close the last opened tab if any exist
            count = tab_spans.count()
            if count == 0:
                self.logger.log("No invoice tabs found to close")
                return 0

            span = tab_spans.nth(count - 1)
            tab_name = span.inner_text().strip()
            close_icon = span.locator(
                "xpath=../../span[contains(@class,'e-close-icon')]"
            )
            close_icon.click()
            span.wait_for(state="detached", timeout=5000)
            self.logger.log(f"Closed last invoice tab {tab_name}")
            return 1

        except Exception as e:
            self.logger.log_error(f"Failed to close invoice tab(s): {str(e)}")
            self.take_screenshot("Failed to close invoice tab")
            raise


