import os
import sys
import argparse
from pathlib import Path
from dotenv import load_dotenv
from openai import OpenAI
import re
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from threading import Thread

# set env file to /home/jake/Code/.env
load_dotenv("/home/jake/Code/.env")

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

from rich.console import Console
from rich.syntax import Syntax

console = Console()


def get_completion(prompt: str, model="gpt-4", temperature=0.3):
    response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        temperature=temperature,
    )
    return response.choices[0].message.content.strip()


def extract_all_code_blocks(response: str) -> str:
    blocks = re.findall(r"```(?:\w+)?\n?(.*?)```", response, re.DOTALL)
    return "\n\n".join(block.strip() for block in blocks) if blocks else response.strip()


def extract_class_names(filepath: Path):
    if not filepath.exists():
        return []
    try:
        with open(filepath, "r") as f:
            content = f.read()
        return re.findall(r"^class (\w+)", content, re.MULTILINE)
    except Exception as e:
        console.print(f"[red]Failed to read classes from file: {e}[/red]")
        return []


def extract_method_names_by_class(filepath: Path, class_name: str):
    if not filepath.exists() or not class_name:
        return []
    try:
        with open(filepath, "r") as f:
            lines = f.readlines()

        inside_class = False
        indent_level = None
        methods = []

        for line in lines:
            if re.match(rf"^class {class_name}\b", line):
                inside_class = True
                continue
            if inside_class:
                if re.match(r"^\S", line):  # outdent = end of class
                    break
                method_match = re.match(r"^(\s+)def (\w+)\(", line)
                if method_match:
                    if indent_level is None:
                        indent_level = len(method_match.group(1))
                    if len(method_match.group(1)) == indent_level:
                        method_name = method_match.group(2)
                        if method_name != "__init__":
                            methods.append(method_name)

        return methods
    except Exception as e:
        console.print(f"[red]Failed to read methods for class {class_name}: {e}[/red]")
        return []


def insert_or_replace_in_class(filepath: Path, class_name: str, method_name: str, content: str, prompt: str):
    try:
        with open(filepath, "r") as f:
            lines = f.readlines()

        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        header = (
            "\n" + "#" * 80 + "\n"
            f"# \U0001F6E0\ufe0f  Generated by CodeClerk\n"
            f"# \U0001F4CC Prompt: {prompt}\n"
            f"# \U0001F552 Timestamp: {timestamp}\n"
            + "#" * 80 + "\n"
        )

        new_lines = []
        inside_class = False
        inside_target_method = False
        indent = "    "
        replaced = False

        for i, line in enumerate(lines):
            if re.match(rf"^class {class_name}\b", line):
                inside_class = True
                new_lines.append(line)
                continue
            if inside_class:
                if re.match(r"^\S", line):  # dedent = class ends
                    if not replaced and method_name:
                        new_lines.append(f"{indent}# insert failed, method not found\n")
                    if not method_name:
                        new_lines.append("\n" + indent + header.replace("\n", f"\n{indent}") + indent + content.replace("\n", f"\n{indent}") + "\n")
                    inside_class = False
                if method_name:
                    if re.match(rf"^\s+def {method_name}\(", line):
                        inside_target_method = True
                        replaced = True
                        new_lines.append("\n" + indent + header.replace("\n", f"\n{indent}") + indent + content.replace("\n", f"\n{indent}") + "\n")
                        continue
                    if inside_target_method and re.match(r"^\s+def ", line):
                        inside_target_method = False
                if not inside_target_method:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        with open(filepath, "w") as f:
            f.writelines(new_lines)

        console.print(f"‚úÖ {'Replaced' if method_name else 'Inserted'} into class '{class_name}' in [bold green]{filepath}[/bold green]")
    except Exception as e:
        console.print(f"[red]Failed to inject code: {e}[/red]")

def write_to_file(filepath: Path, content: str, append: bool, prompt: str):
    mode = "a" if append else "w"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = (
        "\n" + "#" * 80 + "\n"
        f"# üõ†Ô∏è  Generated by CodeClerk\n"
        f"# üìå Prompt: {prompt}\n"
        f"# üïí Timestamp: {timestamp}\n"
        + "#" * 80 + "\n"
    )
    cleaned = extract_all_code_blocks(content)
    with open(filepath, mode) as f:
        f.write(header + cleaned + "\n")
    console.print(f"‚úÖ Code {'appended to' if append else 'written to'} [bold green]{filepath}[/bold green]")

def run_gui():
    def update_class_dropdown():
        filepath = Path(filepath_entry.get().strip())
        class_dropdown['values'] = extract_class_names(filepath)
        class_dropdown.set('')
        method_dropdown.set('')
        method_dropdown['values'] = []

    def on_class_select(event):
        filepath = Path(filepath_entry.get().strip())
        selected_class = class_dropdown.get()
        method_dropdown['values'] = extract_method_names_by_class(filepath, selected_class)
        method_dropdown.set('')

    def on_submit():
        prompt = prompt_entry.get("1.0", "end-1c").strip()
        filepath_input = filepath_entry.get().strip()

        if not prompt:
            messagebox.showwarning("Missing Prompt", "Please enter a prompt.")
            return

        filepath = Path(filepath_input) if filepath_input else Path.cwd() / "ai_written_functions.py"
        append = filepath.exists()
        selected_class = class_dropdown.get().strip()
        selected_method = method_dropdown.get().strip()

        def worker():
            console.print("[bold cyan]Generating code...[/bold cyan]")
            try:
                code_raw = get_completion(prompt)
                code = extract_all_code_blocks(code_raw)
                if selected_class:
                    insert_or_replace_in_class(filepath, selected_class, selected_method if selected_method else None, code, prompt)
                else:
                    write_to_file(filepath, code, append, prompt)
                messagebox.showinfo("Success", f"Code written to {filepath}")
                update_class_dropdown()
            except Exception as e:
                messagebox.showerror("Error", str(e))

        Thread(target=worker).start()

    def choose_file():
        filepath = filedialog.asksaveasfilename(defaultextension=".py", filetypes=[("Python Files", "*.py")])
        if filepath:
            filepath_entry.delete(0, tk.END)
            filepath_entry.insert(0, filepath)
            update_class_dropdown()

    root = tk.Tk()
    root.title("CodeClerk GUI")
    root.geometry("600x450")

    tk.Label(root, text="Enter your prompt:", font=("Arial", 12)).pack(pady=(10, 0))
    prompt_entry = tk.Text(root, font=("Consolas", 11), height=4)
    prompt_entry.pack(padx=10, pady=5, fill="x")

    path_frame = tk.Frame(root)
    path_frame.pack(pady=5, fill="x", padx=10)
    tk.Label(path_frame, text="Destination File:", font=("Arial", 10)).pack(side="left")
    filepath_entry = tk.Entry(path_frame, font=("Consolas", 10), width=50)
    filepath_entry.insert(0, str(Path.cwd() / "ai_written_functions.py"))
    filepath_entry.pack(side="left", padx=5, fill="x", expand=True)
    tk.Button(path_frame, text="Browse", command=choose_file).pack(side="right")

    class_frame = tk.Frame(root)
    class_frame.pack(pady=5, fill="x", padx=10)
    tk.Label(class_frame, text="Detected Classes:", font=("Arial", 10)).pack(side="left")
    class_dropdown = ttk.Combobox(class_frame, font=("Consolas", 10), state="readonly")
    class_dropdown.pack(side="left", padx=5, fill="x", expand=True)
    class_dropdown.bind("<<ComboboxSelected>>", on_class_select)

    method_frame = tk.Frame(root)
    method_frame.pack(pady=5, fill="x", padx=10)
    tk.Label(method_frame, text="Methods in Class:", font=("Arial", 10)).pack(side="left")
    method_dropdown = ttk.Combobox(method_frame, font=("Consolas", 10), state="readonly")
    method_dropdown.pack(side="left", padx=5, fill="x", expand=True)

    submit_button = tk.Button(root, text="Generate Code", command=on_submit, font=("Arial", 12), bg="#4CAF50", fg="white")
    submit_button.pack(pady=20)

    update_class_dropdown()
    root.mainloop()


if __name__ == "__main__":
    run_gui()